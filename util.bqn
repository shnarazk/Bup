âŸ¨
  If,IfElse,_doWhile_,Match,Select,Switch,Test,
  Swap,
  Tokenize,StartsWith,ParseInt,ParseInts,ParseFloats,color,term,
  Debug,Progress,
  MaxAt,MinAt,
  AbsolutePath,DataFile,
  version
âŸ© â‡

#
# program structure
#
If      â† {ğ•âŸğ•@}Â´                 # Also Repeat
IfElse  â† {câ€¿Tâ€¿F : câ—¶Fâ€¿T@}
_doWhile_ â† {ğ”¾@ â‹„ ğ”½ â€¢_while_ ğ”¾}
# For     â† {Iâ€¿Câ€¿Pâ€¿A : I@ â‹„ (Pâˆ˜A)â€¢_while_ C}
Match   â† {ğ•ğ•¨}Â´
Select  â† {(âŠ‘ğ•©)â—¶(1â†“ğ•©)@}
Switch  â† {câ†âŠ‘ğ•© â‹„ mâ€¿aâ†<Ë˜â‰âˆ˜â€¿2â¥Š1â†“ğ•© â‹„ (mâŠ¸âŠâŒ¾<C)â—¶a@}
Test    â† {fnâ†{Câ€¿Ağ•Še : Câ—¶Aâ€¿E}Â´ğ•© â‹„ Fn@}

#
# list operations
#
#     Swap list: swap the first element and the second one of the `list`
# iâ€¿j Swap list: swap the `i`-th element and the `j`-th one of the `list`
Swap â† {0â€¿1 ğ•Š ğ•© ; â‹ˆËœÂ´âŒ¾(ğ•¨âŠ¸âŠ)ğ•©}

Partition â† {w ğ•Š x : xâŠ”Ëœ-Â¬({+`1âˆ¾<Â´Ë˜2â†•ğ•©}Ã—Â¬)xâˆŠw}
# "Partition spec1" ! âŸ¨"A","BC","D","E"âŸ©  â‰¡ "x,z" Partition "xA,BCzzDx,zEx"
# "Partition spec2" ! âŸ¨"AB","C","DE"âŸ©     â‰¡   " " Partition "AB C  DE"
# "Partition spec3" ! âŸ¨âŸ¨Â¯3,Â¯2âŸ©,âŸ¨0âŸ©,âŸ¨2,3âŸ©âŸ© â‰¡  Â¯1â€¿1 Partition Â¯3+â†•7

#
# string operations
#
StartsWith  â† âŠ¢â‰¡â†‘ËœâŸœâ‰ 
ParseFloats â† â€¢ParseFloatÂ¨Â·(âˆ¨Â´"0123456789"âŠ¸âˆŠ)Â¨âŠ¸/"0123456789.-"âŠ¸((âŠ¢-ËœÂ¬Ã—Â·+`Â»âŠ¸<)âˆ˜(Â¬âˆŠ)ËœâŠ”âŠ¢)
ParseInts   â† âŒŠâˆ˜â€¢ParseFloatÂ¨Â·(âˆ¨Â´"0123456789"âŠ¸âˆŠ)Â¨âŠ¸/"0123456789-"âŠ¸((âŠ¢-ËœÂ¬Ã—Â·+`Â»âŠ¸<)âˆ˜(Â¬âˆŠ)ËœâŠ”âŠ¢)
ParseInt    â† âŠ‘ParseInts

Tokenize â† {" " ğ•Š ğ•© ; (ğ•©Â¬âˆ˜âˆŠğ•¨)(Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âŠ¸âŠ”ğ•©}
# "Tokenize spec1" ! âŸ¨"A","B,C,","D"âŸ©  â‰¡  " " Tokenize "A B,C, D"
# "Tokenize spec2" ! âŸ¨"A","B","C","D"âŸ© â‰¡ " ," Tokenize "A B,C, D"

color â† {
  # https://en.wikipedia.org/wiki/ANSI_escape_code
  esc     â‡ @+27
  csi     â‡ escâˆ¾"["
  black   â‡ csiâˆ¾"30m"
  red     â‡ csiâˆ¾"31m"
  green   â‡ csiâˆ¾"32m"
  yellow  â‡ csiâˆ¾"33m"
  blue    â‡ csiâˆ¾"34m"
  magenta â‡ csiâˆ¾"35m"
  cyan    â‡ csiâˆ¾"36m"
  white   â‡ csiâˆ¾"37m"
  reverse â‡ csiâˆ¾"001m"
  reset   â‡ csiâˆ¾"0m"
  RGB â‡ {
          ğ•Š râ€¿gâ€¿b : escâˆ¾"[38;2;"âˆ¾(â€¢Fmt r)âˆ¾";"âˆ¾(â€¢Fmt g)âˆ¾";"âˆ¾(â€¢Fmt b)âˆ¾"m" ;
        0 ğ•Š râ€¿gâ€¿b : escâˆ¾"[38;2;"âˆ¾(â€¢Fmt r)âˆ¾";"âˆ¾(â€¢Fmt g)âˆ¾";"âˆ¾(â€¢Fmt b)âˆ¾"m" ;
    râ€¿gâ€¿b ğ•Š 0     : escâˆ¾"[48;2;"âˆ¾(â€¢Fmt r)âˆ¾";"âˆ¾(â€¢Fmt g)âˆ¾";"âˆ¾(â€¢Fmt b)âˆ¾"m" ;
       bg ğ•Š fg    : (bg ğ•Š 0)âˆ¾ğ•Š fg
  }
  Out â‡ {c ğ•Š t : câˆ¾tâˆ¾reset}
  Fmt â‡ {c ğ•Š t : câˆ¾(â€¢Fmt t)âˆ¾reset}
}
term â† {
  # https://en.wikipedia.org/wiki/ANSI_escape_code
  lf â‡ @ + 10
  cr â‡ @ + 13
  esc â‡ @ + 27
  csi â‡ escâˆ¾"["
  reverse â‡ csiâˆ¾"001m"
  reset â‡ csiâˆ¾"0m"
  Revert â‡ {â€¢term.OutRawâ€¢ToUTF8 csiâˆ¾(â€¢Fmt ğ•©)âˆ¾"A"âˆ¾csiâˆ¾"1G"âˆ¾csiâˆ¾"0J"}
  Up â‡ {
    â€¢term.OutRawâ€¢ToUTF8 csiâˆ¾(â€¢Fmt ğ•©)âˆ¾"A" ;
    csiâˆ¾(â€¢Fmt ğ•©)âˆ¾"A"
  }
  clear â‡ csiâˆ¾"1G"âˆ¾csiâˆ¾"0J"
  Print â‡ {
    â€¢term.OutRawâ€¢ToUTF8 â€¢Fmt ğ•© ;
    â€¢term.OutRawâ€¢ToUTF8 ğ•¨âˆ¾(â€¢Fmt ğ•©)âˆ¾reset
  }
  Println â‡ {
    â€¢Out â€¢Fmt ğ•© ;
    â€¢Out ğ•¨âˆ¾(â€¢Fmt ğ•©)âˆ¾reset
  }
  Out â‡ {
    â€¢term.OutRawâ€¢ToUTF8 ğ•©âˆ¾reset ;
    â€¢term.OutRawâ€¢ToUTF8 ğ•¨âˆ¾ğ•©âˆ¾reset
  }
  OutLn â‡ {
    â€¢Out ğ•© ;
    â€¢Out ğ•¨âˆ¾ğ•©âˆ¾reset
  }
}

Debug â† {
     ğ•Š ğ•© : "debug" ğ•Š ğ•© ;
  âŸ¨âŸ© ğ•Š ğ•© : ğ•© ;
   ğ•¨ ğ•Š ğ•© :
    label â† (220â€¿220â€¿220 color.RGB 180â€¿80â€¿80)
    text  â† color.RGB 20â€¿100â€¿200
    label term.Outln " - "âˆ¾ğ•¨âˆ¾":"âˆ¾(' 'Ë™Â¨â†•8-8|5+â‰ ğ•¨)âˆ¾text color.Fmt ğ•©
    ğ•©
}

# ğ•¨ should be a number
# - 0 for displaying without pause
# - âŸ¨âŸ© or @ for returning ğ•© without display
# - n for displaying ğ•© for n mili sec.
# - âˆ for displaying without overwriting
Progress â† {
  ğ•Š ğ•©      : 0 ğ•Š ğ•© ;
  0 ğ•Š ğ•©    :
    textc â† color.RGB 20â€¿100â€¿200
    len â† +Â´term.lf= text â† {0=â€¢Type ğ•© ? 1==ğ•© ? âˆ§Â´(2=â€¢Type)Â¨ğ•© ? ğ•© ; â€¢Fmt ğ•©}ğ•©
    textc term.OutLn text
    term.Out term.csiâˆ¾(â€¢Fmt 1+len)âˆ¾"A"âˆ¾term.clear
    ğ•© ;
  @ ğ•Š ğ•©    : ğ•© ;
  âŸ¨âŸ© ğ•Š ğ•©   : ğ•© ;
  spec ğ•Š ğ•© :
    label â† (220â€¿220â€¿220 color.RGB 180â€¿80â€¿80)
    textc â† color.RGB 20â€¿100â€¿200
    len â† +Â´term.lf= text â† {0=â€¢Type ğ•© ? 1==ğ•© ? âˆ§Â´(2=â€¢Type)Â¨ğ•© ? ğ•© ; â€¢Fmt ğ•©}ğ•©
    {
      1=â€¢Type spec ?
        textc term.OutLn text
        {0<spec ? âˆ>spec ? â€¢Delay spec ; @} ;
      1==spec ? âˆ§Â´(2=â€¢Type)Â¨spec ?
        label term.OutLn specâˆ¾":"âˆ¾(' 'Ë™Â¨â†•8-8|5+â‰ spec)âˆ¾textc color.Out text ;
      "invalid ğ•¨ for Progress"!0
    }
    {âˆ>spec ? term.Out term.csiâˆ¾(â€¢Fmt 1+len)âˆ¾"A"âˆ¾term.clear ; @}
    ğ•©
}

#
# math functions
#
# This does not work with depthâ‰¥2
# TODO: as âŠ‘âˆ§âŒ¾(ğ•¨âŠ)Â¨
MaxAt â† {n F l : {ğ•¨>â—‹(nâŠ¸âŠ‘)ğ•© ? ğ•¨ ; ğ•©}Â´l}
MinAt â† {n F l : {ğ•¨<â—‹(nâŠ¸âŠ‘)ğ•© ? ğ•¨ ; ğ•©}Â´l}

#
# file operations
#
AbsolutePath â† {'/'=âŠ‘ğ•© ? ğ•© ; â€¢wdpathâˆ¾"/"âˆ¾ğ•©}
DataFile â† AbsolutePathâˆ˜{0<â‰ ğ•© ? âŠ‘ğ•© ; ğ•¨}

envâ†{
  vars â‡ â‰>âŠ‘âˆ˜âŠâŸœ'='âŠ¸(â†‘â‹ˆ1âŠ¸â†“âˆ˜â†“)Â¨{-Â¬(Â¬Ã—1++`)ğ•©=@+10}âŠ¸âŠ”1âŠ‘â€¢SH<"env"
  Var â‡ {@ğ•Šğ•© ; âŠâŸœğ•©âŠ¸âŠâŸœ(âˆ¾âŸœğ•¨)Ëvars}
  Map â‡ {@â‰¡ğ•© ? ğ•¨ ; ğ•©}Â¨âŸœ(@âŠ¸Var)
}
# "env.Var takes default"  ! ".âˆ."    â‰¡ ".âˆ."      env.VarâŒ¾â‹ˆ "NOT_DEF"
# "env.Map takes default"  ! ".âˆ."    â‰¡ ".âˆ."    âˆ¾âˆ˜env.Mapâ—‹â‹ˆ "NOT_DEF"
# "env.Map takes defaults" ! "Â¯âˆ"â€¿"âˆ" â‰¡ "Â¯âˆ"â€¿"âˆ" âˆ¾âˆ˜env.Mapâ—‹â‹ˆ "NOT_DEF1"â€¿"NOT_DEF2"

version â† "0.7.3"
