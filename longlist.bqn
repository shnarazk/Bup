# Since BQN uses immutable data structures, making long lists
# by adding elements repeately is compeletely impractical.
# If you have to build such a list, you should use multi-level addressing storage
# building from an index-vector and segments.

# This implementation does not support:
# - remove elements
# - modify elements
# but still works well on AoC y2018 day18.
LongList â‡ {
    chunk â† ğ•©
    vec â‡ âŸ¨âŸ¨âŸ©âŸ©
    Get â‡ {ğ•Š ğ•© : c â† ğ•©âŒŠâˆ˜Ã·chunk â‹„ (chunk|ğ•©)âŠ‘câŠ‘vec}
    Add â‡ { chunk=â‰ Â¯1âŠ‘vec ? vec âˆ¾âŸœâŸ¨ğ•©âŸ© â†© ; vec âˆ¾âŸœğ•©âŒ¾(Â¯1âŠ¸âŠ‘) â†© }
    Size â‡ {ğ•¤ â‹„ +Â´â‰ Â¨vec}
    Tail â‡ {
      ğ•Š n : nâ‰¤Size@ ? (-n){ (-ğ•¨)â‰¤â‰ ğ•© ? ğ•¨â†‘ğ•© ; ğ•¨â†‘âˆ¾âŸœğ•© Â¯2âŠ‘vec}Â¯1âŠ‘vec ;
      ğ•Š n : âˆ¾vec
    }
  }
  # storage lognLint 100000
  # storage.AddÂ¨ 1â€¿3â€¿5
  # "dump" util.Debug storage.vec
  # "get" util.Debug storage.GetÂ¨ 0â€¿2â€¿1
  # "tail" util.Debug storage.Tail 2
  # "size" util.Debug storage.Size@
