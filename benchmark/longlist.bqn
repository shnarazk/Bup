#!/usr/bin/env cbqn
env â† {vâ‡â‰>âŠ‘âˆ˜âŠâŸœ'='âŠ¸(â†‘â‹ˆ1â†“â†“)Â¨{-Â¬(Â¬Ã—1++`)ğ•©=@+10}âŠ¸âŠ”1âŠ‘â€¢SH<"env",Varâ‡{âŠâŸœğ•©âŠ¸âŠâŸœ(âˆ¾âŸœ@)Ëv}}
util â† â€¢Import "/util.bqn"âˆ¾Ëœâˆ¾env.Varâ‹ˆ"BQN_LIB"

# Since BQN uses immutable data structures, in-place updating
# is crucial. But it's not impossible in some case.
# A solution is passing namespace intead of passing object itself
# as an argument.
LongList â‡ {
    chunk â† ğ•©
    vec â‡ âŸ¨âŸ¨âŸ©âŸ©
    Get â‡ {ğ•Š ğ•© : c â† ğ•©âŒŠâˆ˜Ã·chunk â‹„ (chunk|ğ•©)âŠ‘câŠ‘vec}
    Add â‡ { chunk=â‰ Â¯1âŠ‘vec ? vec âˆ¾âŸœâŸ¨ğ•©âŸ© â†© ; vec âˆ¾âŸœğ•©âŒ¾(Â¯1âŠ¸âŠ‘) â†© }
    Size â‡ {ğ•¤ â‹„ +Â´â‰ Â¨vec}
    Tail â‡ {
      ğ•Š n : nâ‰¤Size@ ? (-n){ (-ğ•¨)â‰¤â‰ ğ•© ? ğ•¨â†‘ğ•© ; ğ•¨â†‘âˆ¾âŸœğ•© Â¯2âŠ‘vec}Â¯1âŠ‘vec ;
      ğ•Š n : âˆ¾vec
    }
  }

util.Debug start_length â† 1e6
amount â† 1e5
l â† start_lengthâ†‘Ï€
ll â† Longlist 100000
{ll.Add Ï€ â‹„ ğ•©+1}â€¢_while_(start_lengthâŠ¸>)0
!âŸœ(start_lengthâŠ¸â‰¡) â‰ l
!âŸœ(start_lengthâŠ¸â‰¡) ll.Size@

repeat â† 1
"list"     util.Debug repeat {{l â†© lâˆ¾Ï€ â‹„ ğ•©+1}â€¢_while_(ğ•©âŠ¸>)0}â€¢_timed amount
"in-place update" util.Debug repeat {{l  âˆ¾âŸœÏ€ â†©â‹„ ğ•©+1}â€¢_while_(ğ•©âŠ¸>)0}â€¢_timed amount
"list argument" util.Debug repeat {{câ€¿l : l â†© lâˆ¾Ï€ â‹„ âŸ¨c+1,lâŸ©}â€¢_while_(ğ•©>âŠ‘)0â€¿l}â€¢_timed amount
"in-place argument" util.Debug repeat {{câ€¿l : l âˆ¾âŸœÏ€ â†© â‹„ âŸ¨c+1,lâŸ©}â€¢_while_(ğ•©>âŠ‘)0â€¿l}â€¢_timed amount
"longlist" util.Debug repeat {{ll.Add Ï€ â‹„ ğ•©+1}â€¢_while_(ğ•©âŠ¸>)0}â€¢_timed amount
!âŸœ((start_length+repeatÃ—amount)âŠ¸â‰¡) â‰ l
!âŸœ((start_length+repeatÃ—amount)âŠ¸â‰¡) ll.Size@
util.Debug "done"
